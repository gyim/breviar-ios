//
//  BRPrayerViewController.m
//  Breviar
//
//  Created by Gyimesi Akos on 9/7/12.
//
//

#import "BRPrayerViewController.h"
#import "BRSettings.h"
#import "BRCGIQuery.h"
#import "BRUtil.h"
#import "mydefs.h"
#import <AVFoundation/AVFoundation.h>
#import <MediaPlayer/MediaPlayer.h>

@interface BRPrayerViewController ()

@property (strong, nonatomic) BRPrayerViewController *subpageController;
@property (strong, nonatomic) BRSpeechController *speechController;

@end

@implementation BRPrayerViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    self.speechController = [[BRSpeechController alloc] init];
    self.speechController.delegate = self;
}

- (void)viewWillAppear:(BOOL)animated {
    // If we are coming from a subpage, move its shared webview here
    if (self.subpageController) {
        self.webView = self.subpageController.webView;
        [self setupSharedWebView];
    }
    
    // The body will get generated on demand, if it hasn't been already generated by previous request
    [self setHtmlBody:self.prayer.body forPrayer:self.prayer.queryId];
    
    [super viewWillAppear:animated];
    
    self.navigationItem.title = self.prayer.title;
    
    [self.navigationController setToolbarHidden:NO animated:animated];
    [self updateNightModeButtonTitle];
    [self updateFontItems];

    [self.speechController beginSession:self.prayer];
    self.speakItem.image = [UIImage imageNamed:@"speaker_off"];
}

- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];
    
    self.prayer.scrollOffset = self.webView.scrollView.contentOffset.y;
    self.prayer.scrollHeight = self.webView.scrollView.contentSize.height;
    
    [self.speechController endSession];
}

- (void)viewDidDisappear:(BOOL)animated
{
    [super viewDidDisappear:animated];
}

- (void)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection
{
    [super traitCollectionDidChange: previousTraitCollection];
    if (@available(iOS 12.0, *)) {
        if (previousTraitCollection.userInterfaceStyle != self.traitCollection.userInterfaceStyle) {
            [self updateNightModeButtonTitle];
            [self refreshPrayer];
        }
    }
}

- (void)setHtmlBody:(NSString *)body forPrayer:(NSString *)prayerId
{
    self.htmlContent = [NSString stringWithFormat:@"<div id=\"prayer-%@\">%@</div>", prayerId, body];
}

- (IBAction)toggleNightMode:(id)sender
{
    BOOL isDarkMode = NO;
    if (@available(iOS 12.0, *)) {
        isDarkMode = (self.traitCollection.userInterfaceStyle == UIUserInterfaceStyleDark);
    }

    // Toggle between automatic color scheme and dark/light, based on current color scheme
    NSString *colorScheme = [[BRSettings instance] stringForOption:@"colorScheme"];
    if (!colorScheme || [colorScheme isEqualToString:@"auto"]) {
        colorScheme = isDarkMode ? @"light" : @"dark";
    } else if ([colorScheme isEqualToString:@"dark"]) {
        colorScheme = isDarkMode ? @"light" : @"auto";
    } else {
        colorScheme = isDarkMode ? @"auto" : @"dark";
    }

    [[BRSettings instance] setString:colorScheme forOption:@"colorScheme"];
    [self updateNightModeButtonTitle];
    [self refreshPrayer];
}

- (void)updateNightModeButtonTitle
{
    BOOL nightMode = NO;
    if (@available(iOS 12.0, *)) {
        nightMode = (self.traitCollection.userInterfaceStyle == UIUserInterfaceStyleDark);
    }

    NSString *colorScheme = [[BRSettings instance] stringForOption:@"colorScheme"];
    if ([colorScheme isEqualToString:@"light"]) {
        nightMode = NO;
    } else if ([colorScheme isEqualToString:@"dark"]) {
        nightMode = YES;
    }

    self.nightModeItem.image = nightMode ? [UIImage imageNamed:@"night_mode_on"] : [UIImage imageNamed:@"night_mode_off"];
}

- (IBAction)playSpeaker:(id)sender
{
    [self.speechController startPlayback];
}

- (IBAction)pauseSpeaker:(id)sender
{
    [self.speechController pausePlayback];
}

- (IBAction)toggleSpeaker:(id)sender
{
    [self.speechController togglePlayback];
}

- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation
{
    [super webView:webView didFinishNavigation:navigation];
    
    if (self.prayer.scrollOffset > 0 && self.prayer.scrollHeight > 0) {
        CGFloat height = self.webView.scrollView.contentSize.height;
        CGFloat maxOffset = height - self.webView.frame.size.height;
        CGFloat scrollOffset = self.prayer.scrollOffset * height / self.prayer.scrollHeight;
        self.webView.scrollView.contentOffset = CGPointMake(0, MIN(scrollOffset, maxOffset));
    }
}

- (IBAction)increaseFontSize:(id)sender
{
    [self modifyFontSize:+2];
}

- (IBAction)decreaseFontSize:(id)sender
{
    [self modifyFontSize:-2];
}

- (void)modifyFontSize:(NSInteger)sizeDiff
{
    BRSettings *settings = [BRSettings instance];
    settings.prayerFontSize += sizeDiff;
    [self refreshPrayer];
    [self updateFontItems];
}

- (void)updateFontItems
{
    BRSettings *settings = [BRSettings instance];
    self.increaseFontItem.enabled = (settings.prayerFontSize < BR_MAX_FONT_SIZE);
    self.decreaseFontItem.enabled = (settings.prayerFontSize > BR_MIN_FONT_SIZE);
}

- (void)refreshPrayer
{
    self.prayer.scrollOffset = self.webView.scrollView.contentOffset.y;
    self.prayer.scrollHeight = self.webView.scrollView.contentSize.height;
    [self setHtmlBody:self.prayer.body forPrayer:self.prayer.queryId];
    [self updateWebViewContent];
    [self.speechController resetText];
}

#pragma mark -
#pragma mark BRSpeechControllerDelegate

- (void)speechStateChanged:(BRSpeechState)speechState {
    NSLog(@"speechStateChanged: %d", speechState);
    switch (speechState) {
        case BRSpeechDisabled:
        case BRSpeechPaused:
            self.speakItem.image = [UIImage imageNamed:@"speaker_off"];
            break;
        case BRSpeechStarting:
        case BRSpeechPlaying:
            self.speakItem.image = [UIImage imageNamed:@"speaker_on"];
    }
}

#pragma mark -
#pragma mark Handling subpages

- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    NSURLRequest *request = navigationAction.request;
    NSString *cgiName = [NSString stringWithUTF8String:SCRIPT_NAME];
    NSString *appName = [[[NSBundle mainBundle] objectForInfoDictionaryKey:(NSString *)kCFBundleNameKey] stringByAppendingString:@".app"];
    [self registerLinkClick];

    if ([request.URL.lastPathComponent isEqualToString:cgiName]) {
        // Parse URL
        NSArray *argList = [request.URL.query componentsSeparatedByString:@"&"];
        NSMutableDictionary *args = [[NSMutableDictionary alloc] init];
        for (NSString *kv in argList) {
            NSArray *kvParts = [kv componentsSeparatedByString:@"="];
            NSString *k = [kvParts objectAtIndex:0];
            NSString *v = [kvParts objectAtIndex:1];
            [args setObject:v forKey:k];
        }

        // Parse static text query
        NSString *staticTextId = [args objectForKey:@"st"];
        if (staticTextId) {
            // Open static text in subpage
            BRPrayer *prayer = [BRPrayer prayerForStaticTextId:staticTextId];

            self.subpageController = [self.storyboard instantiateViewControllerWithIdentifier:@"PrayerViewController"];
            self.subpageController.webView = self.webView;
            self.subpageController.prayer = prayer;

            [UIApplication sharedApplication].statusBarHidden = NO;
            self.navigationController.navigationBarHidden = NO;
            self.navigationController.navigationBar.alpha = 1.0;
            self.navigationController.toolbarHidden = NO;
            self.navigationController.toolbar.alpha = 1.0;

            [self.navigationController pushViewController:self.subpageController animated:YES];
        } else {
            // Replace current prayer text
            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{
                self.prayer.extraOpts = args;
                [self.prayer refreshText];

                dispatch_async(dispatch_get_main_queue(), ^{
                    [self refreshPrayer];
                });
            });
        }

        decisionHandler(WKNavigationActionPolicyCancel);
    }
    else if ([request.URL.lastPathComponent isEqualToString:appName] && request.URL.query == nil && request.URL.fragment.length > 0 && navigationAction.navigationType == WKNavigationTypeLinkActivated) {
        NSString *javascript = [NSString stringWithFormat:@"document.getElementsByTagName(\"a\").namedItem(\"%@\").scrollIntoView();", request.URL.fragment];
        [webView evaluateJavaScript:javascript completionHandler:^(id _Nullable result, NSError * _Nullable error) {
            if (result == nil || error != nil) {
                NSLog(@"Cannot evaluate JavaScript: %@", error);
            }
            decisionHandler(WKNavigationActionPolicyCancel);
        }];
    }
    else {
        [super webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];
    }
}

@end
